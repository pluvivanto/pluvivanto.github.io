<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sand Castle</title>
  <subtitle></subtitle>
  <link href="https://pluvivanto.github.io//feed.xml" rel="self"/>
  <link href="https://pluvivanto.github.io//"/>
  
    <updated>2023-10-31T03:07:05Z</updated>
  
  <id>https://pluvivanto.github.io/</id>
  <author>
    <name>pluvivanto</name>
    <email>140719273+pluvivanto@users.noreply.github.com</email>
  </author>
  
    
    <entry>
      <title>Application Configuration in Java Spring: application.properties vs application.yml</title>
      <link href="https://pluvivanto.github.io//posts/application-configuration-in-java-spring:-application.properties-vs-application.yml/"/>
      <updated>2023-10-31T03:07:05Z</updated>
      <id>https://pluvivanto.github.io//posts/application-configuration-in-java-spring:-application.properties-vs-application.yml/</id>
      <content type="html">
        <![CDATA[
      <p>Since I started using Spring Boot, I’ve really taken a liking to it. But there’s this quirky habit that’s formed. Every time I grab a new Spring project from the Spring Initializer, I end up deleting the default application.properties file and crafting a new application.yml file. Then, I fill it with stuff like flags, paths, and database settings, just out of habit. What’s funny is that I can’t exactly explain why I do it, but it’s become a part of my routine. Lately, I’ve decided to face my curiosity head-on and delve into the Spring documentation to better grasp this practice.</p>
<h2>Why Use the “application.*” File?</h2>
<p>Actually, I might not need it, as the document says:</p>
<blockquote>
<p>Spring Boot lets you externalize your configuration so that you can work with the same application code in different environments.</p>
</blockquote>
<p>Using application.* file is called <em>Externalized Configuration</em>. This is handy when you want different settings for different things. Like, having special setups for production, development, or testing. And it goes beyond that, covering situations like MSA or Docker environments.<br>
Keeping configuration apart from code is a smart move in most cases, if not all. Especially in big company codebases, you’d rather not hunt down and modify all the <code>@PropertySource</code> notes in your <code>@Configuration</code> classes every time you release (and believe me, I’ve been there).</p>
<h5>code 1. I’m sure you don’t want to edit every <code>@PropertySource</code> for each environments</h5>
<pre class="language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>
<span class="token annotation punctuation">@PropertySource</span><span class="token punctuation">(</span><span class="token string">"classpath:/com/${my.placeholder:default/path}/app.properties"</span><span class="token punctuation">)</span>
 <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token punctuation">{</span>
     <span class="token annotation punctuation">@Autowired</span>
     <span class="token class-name">Environment</span> env<span class="token punctuation">;</span>
     <span class="token annotation punctuation">@Bean</span>
     <span class="token keyword">public</span> <span class="token class-name">TestBean</span> <span class="token function">testBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token class-name">TestBean</span> testBean <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TestBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         testBean<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>env<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"testbean.name"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token keyword">return</span> testBean<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h2>So, what’s the deal with .properties and .yml?</h2>
<p>When it comes to how they work, they’re basically same. The only difference is the syntax and formatting. Now, let’s check out the example from the official document:</p>
<h5>code 2: application.properties</h5>
<pre class="language-properties"><code class="language-properties"><span class="token key attr-name">my.secret</span><span class="token punctuation">=</span><span class="token value attr-value">${random.value}</span>
<span class="token key attr-name">my.number</span><span class="token punctuation">=</span><span class="token value attr-value">${random.int}</span>
<span class="token key attr-name">my.bignumber</span><span class="token punctuation">=</span><span class="token value attr-value">${random.long}</span>
<span class="token key attr-name">my.uuid</span><span class="token punctuation">=</span><span class="token value attr-value">${random.uuid}</span>
<span class="token key attr-name">my.number-less-than-ten</span><span class="token punctuation">=</span><span class="token value attr-value">${random.int(10)}</span>
<span class="token key attr-name">my.number-in-range</span><span class="token punctuation">=</span><span class="token value attr-value">${random.int[1024,65536]}</span></code></pre>
<h5>code 3: application.yml</h5>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">my</span><span class="token punctuation">:</span>
  <span class="token key atrule">secret</span><span class="token punctuation">:</span> <span class="token string">"${random.value}"</span>
  <span class="token key atrule">number</span><span class="token punctuation">:</span> <span class="token string">"${random.int}"</span>
  <span class="token key atrule">bignumber</span><span class="token punctuation">:</span> <span class="token string">"${random.long}"</span>
  <span class="token key atrule">uuid</span><span class="token punctuation">:</span> <span class="token string">"${random.uuid}"</span>
  <span class="token key atrule">number-less-than-ten</span><span class="token punctuation">:</span> <span class="token string">"${random.int(10)}"</span>
  <span class="token key atrule">number-in-range</span><span class="token punctuation">:</span> <span class="token string">"${random.int[1024,65536]}"</span></code></pre>
<h2>The Verdict</h2>
<p>Personally, I’ll stick with .yml over .properties.<br>
Wondering why? Well, yml seems really organized, pushing developers toward a specific coding style (and, honestly, I’m a fan of that).</p>
<h2>Reference:</h2>
<ul>
<li>https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties.core</li>
<li>https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config</li>
</ul>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>Weird undefined reference - CXX 14 vs 17</title>
      <link href="https://pluvivanto.github.io//posts/weird-undefined-reference-cxx-14-vs-17/"/>
      <updated>2023-10-31T03:07:05Z</updated>
      <id>https://pluvivanto.github.io//posts/weird-undefined-reference-cxx-14-vs-17/</id>
      <content type="html">
        <![CDATA[
      <p>Lately, I've been working on a project that involves migrating our C++17-based solution to an environment that relies on C++14. Honestly, I'm not entirely sure why a client would want such a downgrade, but the customer is king, right?</p>
<p>So, I went ahead and replaced all the features introduced in C++17, like <code>&lt;variant&gt;</code>, <code>&lt;filesystem&gt;</code>, inline variables, lambda capture of <code>*this</code>, <code>constexpr</code> lambdas, <code>__has_include</code>, and, regrettably, one of the most important ones, the <code>[[maybe_unused]]</code> attribute. Most of these changes went smoothly, but I ran into a peculiar issue: undefined references during linking. I was absolutely certain that everything was correctly declared, defined in the header files, and properly linked.</p>
<p>After several days (and a few sleepless nights) pulling my hair out, I finally pinpointed the root cause. The issue stemmed from <code>constexpr static</code> data members in the header files. To be more precise, it's due to the nuances of how C++ treats these members:</p>
<blockquote>
<p>A constexpr specifier used in an object declaration or non-static member function (until C++14) implies const. A constexpr specifier used in a function or static data member (since C++17) declaration implies inline. If any declaration of a function or function template has a constexpr specifier, then every declaration must contain that specifier.</p>
<p>- from <a href="https://en.cppreference.com/w/cpp/language/constexpr">cppreference</a></p>
</blockquote>
<blockquote>
<p>If a const non-inline (since C++17) static data member or a constexpr static data member (since C++11)(until C++17) is <a href="https://en.cppreference.com/w/cpp/language/definition#ODR-use">odr-used</a>, a definition at namespace scope is still required, but it cannot have an initializer.</p>
<p>A constexpr static data member is implicitly inline and does not need to be redeclared at namespace scope. This redeclaration without an initializer (formerly required) is still permitted, but is deprecated. (since C++17)</p>
<pre class="language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">X</span>
<span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">constexpr</span> <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>X<span class="token double-colon punctuation">::</span>n<span class="token punctuation">,</span> <span class="token operator">*</span>q <span class="token operator">=</span> <span class="token operator">&amp;</span>X<span class="token double-colon punctuation">::</span>m<span class="token punctuation">;</span> <span class="token comment">// X::n and X::m are odr-used</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> X<span class="token double-colon punctuation">::</span>n<span class="token punctuation">;</span>                   <span class="token comment">// … so a definition is necessary</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> X<span class="token double-colon punctuation">::</span>m<span class="token punctuation">;</span>               <span class="token comment">// … (except for X::m in C++17)</span></code></pre>
<p>- from <a href="https://en.cppreference.com/w/cpp/language/static">cppreference</a></p>
</blockquote>
<p>This means that I didn't have to re-declare <code>static const</code> and <code>static constexpr</code> member variables in corresponding <code>.cpp</code> files in C++17. But because I'm downgrading the project, I have to do it now.</p>
<p>So, I've solved one problem by re-declaring every <code>static constexpr</code> variable. But what happens when the class is templated? According to the <a href="https://isocpp.org/wiki/faq/templates#templates-defn-vs-decl">Standard C++ Foundation</a>, it's not advisable to split a templated class into declaration and definition.</p>
<p>I scoured for a more elegant, intuitive, and scalable solution but ended up removing the static keyword and creating an instance every time I needed to use the class. I wish I could come up with a better solution, but I don't believe this &quot;problem&quot; can be fixed without refactoring the entire legacy project. It's working, and I'm content with that for now.</p>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>TDD: Test Driven Development – 한빛 MSA</title>
      <link href="https://pluvivanto.github.io//posts/tdd:-test-driven-development-msa/"/>
      <updated>2023-10-31T03:07:05Z</updated>
      <id>https://pluvivanto.github.io//posts/tdd:-test-driven-development-msa/</id>
      <content type="html">
        <![CDATA[
      <p><strong><em>Speaker: MS 코리아 Solutions Architect 정보람님</em></strong></p>
<h2>TDD는 설계-구현-테스트 의 사이클을 빠르게 변하는 요구사항에 맞추기 좋게 하기 위한 것</h2>
<p><img src="../images/presentation1.jpg" alt="TDD lifecycle"><em>TDD lifecycle</em></p>
<p>볼링 게임 – TDD계의 Hello, World!</p>
<h2>TDD pros &amp; cons</h2>
<table>
  <th>pros</th>
  <th>pros</th>
  <tr>
    <td>
      <ul>
        <li>코드 품질 향상</li>
        <li>확장이 용이</li>
        <li>최소기능 단위로 개발해서 수정 및 디버깅이 쉬움</li>
      </ul>
    </td>
    <td>
      <ul>
        <li>초기투자시간 大</li>
        <li>테스트 코드를 작성하기 어려움</li>
        <li>개발 속도가 느리다</li>
      </ul>
    </td>
  </tr>
</table>
<p>stub &amp; mock 참고하기</p>
<h2>TDD 자체가 프로젝트의 목적이 되어서는 주객전도. agile 도 TDD 도 “유연하게” 적용해야 한다!!</h2>
<p>-&gt; 공통 목표를 효율적으로 달성하기 위한 틀로만 활용!
ideal: 프로젝트 전체에 TDD 적용 (이러다가 고꾸라진 프로젝트가 많다)
reality: 복잡도가 높을 것으로 예상되는 부분만 부분적 도입!</p>
<h2>speaker 최근 관심:</h2>
<p><strong>BDD: Behavior Driven Development</strong></p>
<ul>
<li>비즈니스 요구사항에 집중</li>
<li>테스트를 요구사항과 최대한 비슷하게 설계</li>
</ul>
<p><strong>DDD: Domain Driven Development</strong></p>
<ul>
<li>테스트보다도 도메인이 중요 -&gt; MSA 구조 시스템에 적합</li>
</ul>
<h2>TDD examples</h2>
<p><strong>1. 아무도 어떻게 작동하는지 모르는 레거시 프로젝트에서 새 기능 개발</strong></p>
<ul>
<li>레거시 코드를 블랙박스로 취급</li>
<li>기존 코드에 대한 유닛 테스트를 작성</li>
<li>기존 코드 green 상태를 유지하면서 리팩토링</li>
<li>이후 새 기능을 TDD 기반으로 쌓기</li>
</ul>
<p><strong>2. 사용자가 급증하여 버그 급증 –&gt; 핫픽스 제공 –&gt; 변경사항이 적용되고 고객지원 요구가 두배가 됨</strong></p>
<ul>
<li>핫픽스가 기존의 코드를 깨트림</li>
<li>단위 테스트 assertion을 검증/재검토<br>
=&gt; 코드가 문서화된 대로 작동한다는 증거 == 테스트!!</li>
</ul>
<h2>TDD는 언제 쓰면 좋을까?</h2>
<ul>
<li>익숙하지 않은 프로젝트 주제</li>
<li>프로젝트 변경할 때 변경사항이 많은 경우</li>
<li>고객의 요구사항이 자주 바뀔경우</li>
<li>내가 개발하더라도 이 코드를 누가 유지보수할지 모를 경우</li>
</ul>
<h2>TDD는 선택, “테스트” 는 필수!!!</h2>
<p>test coverage는 해당 로직의 중요도에 따라서 결정<br>
-&gt; 중요도 낮은 코드는 coverage 100%아니더라도 OK<br>
회사에서 테스트를 안시켜도 테스트는 꼭!! 하자</p>
<p>live service 기준 일반적으로 test coverage는 70~80% 가 일반적<br>
현실적으론 30% 이하도 많다…</p>
<p>TDD (unit test를 사용한) 는 작은 로직들을 위한 것<br>
큰 로직 테스트는 인수 검사 (acceptance test) 를 하자!</p>

    ]]>
      </content>
    </entry>
  
</feed>